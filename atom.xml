<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChpiTer Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chpiter.net/"/>
  <updated>2020-03-22T10:20:18.865Z</updated>
  <id>https://chpiter.net/</id>
  
  <author>
    <name>ChpiTer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>supervisor</title>
    <link href="https://chpiter.net/2020/03/21/supervisor/"/>
    <id>https://chpiter.net/2020/03/21/supervisor/</id>
    <published>2020-03-21T08:44:01.000Z</published>
    <updated>2020-03-22T10:20:18.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="supervisor介绍"><a href="#supervisor介绍" class="headerlink" title="supervisor介绍"></a>supervisor介绍</h1><p>进程守护</p><h1 id="supervisor组件"><a href="#supervisor组件" class="headerlink" title="supervisor组件"></a>supervisor组件</h1><h2 id="supervisord"><a href="#supervisord" class="headerlink" title="supervisord"></a>supervisord</h2><p>supervisord是supervisor的服务端程序：启动supervisor程序，启动supervisor管理的子进程，响应来自client的请求，重启闪退或异常退出的子进程，把子进程的stderr或stdout记录到日志文件中，生成和处理event。</p><h2 id="supervisorctl"><a href="#supervisorctl" class="headerlink" title="supervisorctl"></a>supervisorctl</h2><p>supervisorctl是客户端程序，有一个类似shell的命令，可以查看子进程状态，启动、停止、重启子进程，获取running子进程的列表等。supervisorctl不仅可以连接到本机的supervd，还可以连接远程的supervisord，本机通过UNIX socke连接，远程通过TCP socket连接。supervisorctl和supervd之间的通信是通过XML_RPC完成的</p><h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><p>Web Server可以在界面上可以进城，Web Server是通过XML_RPC来实现的。</p><h2 id="XML-RPC接口"><a href="#XML-RPC接口" class="headerlink" title="XML_RPC接口"></a>XML_RPC接口</h2><p>用于远程调用的接口</p><h1 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h1><h2 id="unix-http-server"><a href="#unix-http-server" class="headerlink" title="[unix_http_server]"></a>[unix_http_server]</h2><table><thead><tr><th>参数选项</th><th>中文白话</th></tr></thead><tbody><tr><td>file=/tmp/supervisor.sock</td><td>socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行的。如果不设置的话，supervisorctl也就不能用了不设置的话，默认为none。 非必须设置</td></tr><tr><td>;chmod=0700</td><td>这个简单，就是修改上面的那个socket文件的权限为0700不设置的话，默认为0700。 非必须设置</td></tr><tr><td>;chown=nobody:nogroup</td><td>这个一样，修改上面的那个socket文件的属组为user.group不设置的话，默认为启动supervisord进程的用户及属组。非必须设置</td></tr><tr><td>;username=user</td><td>使用supervisorctl连接的时候，认证的用户不设置的话，默认为不需要用户。 非必须设置</td></tr><tr><td>;password=123</td><td>和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密如：{SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d默认不设置。非必须设置</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;supervisor介绍&quot;&gt;&lt;a href=&quot;#supervisor介绍&quot; class=&quot;headerlink&quot; title=&quot;supervisor介绍&quot;&gt;&lt;/a&gt;supervisor介绍&lt;/h1&gt;&lt;p&gt;进程守护&lt;/p&gt;
&lt;h1 id=&quot;supervisor组件&quot;
      
    
    </summary>
    
    
    
      <category term="supervisor" scheme="https://chpiter.net/tags/supervisor/"/>
    
  </entry>
  
  <entry>
    <title>技术团队的组织文化</title>
    <link href="https://chpiter.net/2020/03/16/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%87%E5%8C%96/"/>
    <id>https://chpiter.net/2020/03/16/%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%87%E5%8C%96/</id>
    <published>2020-03-16T12:36:25.000Z</published>
    <updated>2020-03-21T04:23:24.379Z</updated>
    
    <content type="html"><![CDATA[<p>from: 58到家 刘晓飞</p><h1 id="团队文化"><a href="#团队文化" class="headerlink" title="团队文化"></a>团队文化</h1><p>文化建设不分团队大小。<br>团队的是非观，提倡什么、反对什么。<br>人是团队文化的核心。<br><strong>规章制度告诉我们什么不能做，文化倡导我们做什么。两者并不冲突。</strong></p><h1 id="怎样构建团队文化"><a href="#怎样构建团队文化" class="headerlink" title="怎样构建团队文化"></a>怎样构建团队文化</h1><ol><li>Teamleader要以身作则</li><li>要找对的人</li><li>强调团队的价值和荣誉感，让员工有自豪感</li><li>合理的考核和激励制度</li><li>氛围、公平、成长、成就</li></ol><h1 id="Owner精神"><a href="#Owner精神" class="headerlink" title="Owner精神"></a>Owner精神</h1><ul><li>有组织</li><li>有思考 – 不仅是完成任务</li><li>有目标</li><li>有原则</li><li>有执行</li><li>敢决策</li><li>敢担责</li></ul><h2 id="价值体现"><a href="#价值体现" class="headerlink" title="价值体现"></a>价值体现</h2><ul><li>保持团持久的战斗力</li><li>保持团队的凝聚力</li><li>保持生产团队的自豪感</li></ul><h2 id="如何培养"><a href="#如何培养" class="headerlink" title="如何培养"></a>如何培养</h2><ul><li>树立自身的owner精神</li><li>给与充分信任 – 犯错不一定是坏事</li><li>给予足够的关怀</li><li>重贡献轻成就</li><li>多建议少决策</li><li>多鼓励少批评 – 要做到帮助性、建设性的批评</li><li>分享团队成果 – 团队的荣辱与我相关</li><li>贯宣公司战略</li></ul><h2 id="如何管理owner团队"><a href="#如何管理owner团队" class="headerlink" title="如何管理owner团队"></a>如何管理owner团队</h2><ul><li>管理动作要一致</li><li>坚决淘汰消极分子</li><li>合理的考核制度</li><li>不断强调团队的价值</li><li>工作上学会放手（不放松）</li><li>要做团队的保护伞</li></ul><h2 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h2><ul><li>不要期望每个人都有owner精神</li><li>要信任但要有监督</li><li>学会放手但不要置身事外</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;from: 58到家 刘晓飞&lt;/p&gt;
&lt;h1 id=&quot;团队文化&quot;&gt;&lt;a href=&quot;#团队文化&quot; class=&quot;headerlink&quot; title=&quot;团队文化&quot;&gt;&lt;/a&gt;团队文化&lt;/h1&gt;&lt;p&gt;文化建设不分团队大小。&lt;br&gt;团队的是非观，提倡什么、反对什么。&lt;br&gt;人是团队
      
    
    </summary>
    
    
    
      <category term="管理" scheme="https://chpiter.net/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iptables详解及常用规则</title>
    <link href="https://chpiter.net/2020/03/13/iptables%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99/"/>
    <id>https://chpiter.net/2020/03/13/iptables%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99/</id>
    <published>2020-03-13T10:25:48.000Z</published>
    <updated>2020-03-21T04:10:11.419Z</updated>
    
    <content type="html"><![CDATA[<p>引用：</p><ul><li><a href="https://www.cnblogs.com/sunsky303/p/12327863.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunsky303/p/12327863.html</a></li></ul><h1 id="iptables简介"><a href="#iptables简介" class="headerlink" title="iptables简介"></a>iptables简介</h1><p>netfilter/iptables（简称iptables）组成linux平台下的包过滤防火墙，与大多数的linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，<strong>完成封包过滤、封包重定向和网络地址转换（NAT）等功能</strong>。</p><h2 id="iptables基础"><a href="#iptables基础" class="headerlink" title="iptables基础"></a>iptables基础</h2><p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定位为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICP）和服务类型（如HTTP、FTP和SMTP等）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如方形（accept）、拒绝（reject）和丢弃（drop）等。匹配防火墙的主要工作就是添加、修改和删除这些规则。</p><h2 id="iptables和netfilter的关系："><a href="#iptables和netfilter的关系：" class="headerlink" title="iptables和netfilter的关系："></a>iptables和netfilter的关系：</h2><p>这是第一个要说的地方，iptables和netfilter的关系是一个很容易让人搞不清楚的问题。<strong>iptables只是linux防火墙的管理工具而已，位于/sbin/iptables。真正实现防火墙功能的事netfilter，它是linux内核中实现包过滤的内部结构</strong>。</p><h2 id="iptables传输数据包的过程"><a href="#iptables传输数据包的过程" class="headerlink" title="iptables传输数据包的过程"></a>iptables传输数据包的过程</h2><ol><li>当一个数据包进入网卡时，它首先进入prerouting链，内核根据数据包目的IP判断是否需要传送出去</li><li>如果数据包就是进入本机的，它就会沿着图向下移动，到达input链。数据包到了input链后，任何进程都会收到它。本机上运行的程序可以发送书包，这些数据包会经过output链，然后到达postrouting链输出。</li><li>如果数据包是要转发出去，且内核允许转发，数据包就会如图所示向右移动，经过forward链，然后到达postrouting链输出。<br><img src="/images/7775566-d1ad7de240451282.png" alt=""></li></ol><h2 id="iptables的规则表和链"><a href="#iptables的规则表和链" class="headerlink" title="iptables的规则表和链"></a>iptables的规则表和链</h2><p>表（tables）提供特定的功能，<strong>iptables内置了4个表，filter、nat、mangle和raw表，分别用于包过滤、网络地址转换、包重构（修改）和数据跟踪处理</strong>。<br>链（chains）是数据包传播的路径，每一条链其实就是众多规则中的一个检查清单，每一条链中可以由一条或者多条规则。当一个数据包达到一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理数据包；否则iptables将继续检查下一条规则，如果该数据包不符合链中的任意一条规则，iptables就会根据该链预定义的默认策略来处理数据包。<br>iptables采用“表”和“链”的分层结构。在REHL5中是<strong>四张表五个链</strong>。下面罗列一下这四张表和五个链。注意一定要明白这些表和链的关系及作用。<br><img src="/images/7775566-5ec887df41cf1861.png" alt=""></p><h2 id="规则表"><a href="#规则表" class="headerlink" title="规则表"></a>规则表</h2><h3 id="1-Filter表-—-三个链：-input、forward、output"><a href="#1-Filter表-—-三个链：-input、forward、output" class="headerlink" title="1. Filter表 — 三个链： input、forward、output"></a>1. Filter表 — 三个链： input、forward、output</h3><p>作用：过滤数据包<br>内核模块：iptables_filter</p><h3 id="2-Nat表-—-三个链：-prerouting、postrouting、output"><a href="#2-Nat表-—-三个链：-prerouting、postrouting、output" class="headerlink" title="2. Nat表 — 三个链： prerouting、postrouting、output"></a>2. Nat表 — 三个链： prerouting、postrouting、output</h3><p>作用：用于网络地址转换<br>内核模块：iptables_nat</p><h3 id="3-Mangle表-–-五个链：prerouting、postrouting、input、output、forward，即作用于全部链（chains）"><a href="#3-Mangle表-–-五个链：prerouting、postrouting、input、output、forward，即作用于全部链（chains）" class="headerlink" title="3. Mangle表 – 五个链：prerouting、postrouting、input、output、forward，即作用于全部链（chains）"></a>3. Mangle表 – 五个链：prerouting、postrouting、input、output、forward，即作用于全部链（chains）</h3><p>作用：修改数据包的服务类型、TTL，并且可以配置路由实现QPS<br>内核模块：iptables_mangle</p><h3 id="4-Raw表-–-两个链：output、rerouting"><a href="#4-Raw表-–-两个链：output、rerouting" class="headerlink" title="4. Raw表 – 两个链：output、rerouting"></a>4. Raw表 – 两个链：output、rerouting</h3><p>作用：决定数据包是否被状态跟踪机制处理<br>内核模块：iptables_raw</p><p><strong>重要/常用的事Filter和Nat表</strong></p><h2 id="规则链"><a href="#规则链" class="headerlink" title="规则链"></a>规则链</h2><hr><ol><li>input — 进来的数据包应用此规则链中的策略</li><li>output – 外出的数据包应用此规则链中的策略</li><li>forward — 转发数据包时应用此规则链中的策略</li><li>prerouting – 对数据包坐路由选择前应用此规则链中的规则</li></ol><p><strong>（记住！所有的数据包进来的时候都先由这个链处理）</strong><br>5. postrouting — 对数据包作路由选择后应用此规则链中的规则<br><strong>（所有的数据包出来的时候都先由这个链处理）</strong></p><h2 id="规则表之间的优先顺序"><a href="#规则表之间的优先顺序" class="headerlink" title="规则表之间的优先顺序"></a>规则表之间的优先顺序</h2><p><strong>Raw –&gt; Mangle –&gt; Nat –&gt; Filter</strong></p><p>规则链之间的优先顺序（分三种情况）：</p><h3 id="第一种情况“入站数据流向"><a href="#第一种情况“入站数据流向" class="headerlink" title="第一种情况“入站数据流向"></a>第一种情况“入站数据流向</h3><p>从外界到达防火墙的数据包，先被prerouting规则处理（是否修改数据包地址等），之后会进行路由选择（判断该数据包应该发送何处），如果数据包的目的主机是防火墙本机（比如说Internet用户访问防火墙主机中的web服务器的数据包），那么内核将其传给input链进行处理（决定是否允许通过等），通过以后再交给系统上层的应用程序（比如Apache服务器）进行响应。</p><h3 id="第二种情况：转发数据流向"><a href="#第二种情况：转发数据流向" class="headerlink" title="第二种情况：转发数据流向"></a>第二种情况：转发数据流向</h3><p>来自外界的数据包达到防火墙后，首先被prerouting规则链处理，之后会进行路由选择，如果数据包的目的地址是其他外部地址（比如局域网用户通过网关访问QQ站点的数据包），则内核将其传递给forward链进行处理（是否转发或者拦截），然后再交给postrouting规则链（是都修改数据包的地址等）进行处理。</p><h3 id="第三种情况：出站数据流向"><a href="#第三种情况：出站数据流向" class="headerlink" title="第三种情况：出站数据流向"></a>第三种情况：出站数据流向</h3><p>防火墙本机向外部地址发送的数据包（比如防火墙主机中测试公网DNS服务器时），首先被output规则链处理，之后进行路由选择，然后传递给postrouting规则链（是否修改数据包的地址等）进行处理。</p><h2 id="管理和设置iptables规则"><a href="#管理和设置iptables规则" class="headerlink" title="管理和设置iptables规则"></a>管理和设置iptables规则</h2><p><img src="/images/7775566-fb35d0a138063159.jpg" alt=""><br><img src="/images/7775566-736f5a5882a69420.jpg" alt=""></p><h3 id="iptables的基本语法格式"><a href="#iptables的基本语法格式" class="headerlink" title="iptables的基本语法格式"></a>iptables的基本语法格式</h3><p>iptables [-t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转]<br>说明：表名、链名由于指定iptables命令所操作的表和链，命令选项用于指定管理iptables规则的方式（比如：插入、增加、删除、查看等）；条件匹配用于指定对符合什么样的条件的数据包进行处理；目标动作或跳转用于指定数据包的处理方式（比如允许通过、拒绝、丢弃、跳转给其他链处理）。</p><h3 id="iptables命令的管理控制选项"><a href="#iptables命令的管理控制选项" class="headerlink" title="iptables命令的管理控制选项"></a>iptables命令的管理控制选项</h3><p>-A 在指定链的末尾添加（append）一条新的规则<br>-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除<br>-I 在指定链中插入（insert）一条新的规则，默认在第一行添加<br>-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换<br>-L 列出（list）指定链中的所有的规则进行查看<br>-E 重命名用户定义的链，不改变链本身<br>-F 清空（flush）所有规则<br>-N 新建（new-chain）一条用户自己定义的规则链<br>-X 删除指定表中用户自定义的规则链（delete-chain）<br>-P 设置指定链的默认策略（policy）<br>-Z 将所有表的所有链的字节和数据包计数器清零<br>-n 使用数字形式（number）显示输出结果<br>-v 查看规则表详细信息（verbose）的信息<br>-V 查看版本（version）<br>-h 获取帮助（help）</p><h3 id="防火墙处理数据包的四种方式"><a href="#防火墙处理数据包的四种方式" class="headerlink" title="防火墙处理数据包的四种方式"></a>防火墙处理数据包的四种方式</h3><p>Accept 允许数据包通过<br>Drop 直接丢弃数据包，不给任何回应信息<br>Reject 拒绝数据包通过，必要时会给数据发送端一个响应的信息<br>Log 在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则</p><h3 id="iptables防火墙规则的保存和恢复"><a href="#iptables防火墙规则的保存和恢复" class="headerlink" title="iptables防火墙规则的保存和恢复"></a>iptables防火墙规则的保存和恢复</h3><p>iptables-save把规则保存到文件中，再由目录rc.d下的脚本（/etc/rc.d/init.d/iptables）自动装载<br>使用命令iptables-save来保存规则。<br>一般用iptables-save &gt; /etc/sysconfig/iptables 生成保存规则的文件<br>也可以用 service iptables save，它能把规则自动保存在 /etc/sysconfig/iptables中。<br>当计算机启动时，rc.d下的脚本将用命令iptables-restore调用这个文件，从而自动恢复规则。</p><h3 id="删除input链的第一条规则"><a href="#删除input链的第一条规则" class="headerlink" title="删除input链的第一条规则"></a>删除input链的第一条规则</h3><p>iptables -D input 1</p><h3 id="iptables防火墙常用的策略"><a href="#iptables防火墙常用的策略" class="headerlink" title="iptables防火墙常用的策略"></a>iptables防火墙常用的策略</h3><ol><li><p>拒绝进入防火墙的所有ICMP协议数据包<br>iptables -I INPUT -p icmp -j REJECT</p></li><li><p>允许防火墙转发除了ICMP协议之外的所有数据包<br>iptables -A FORWARD -p !icmp -j ACCEPT<br>说明：使用“!”可以将条件取反</p></li><li><p>拒绝转发来自192.168.1.10主机的数据，允许转发来自192.168.0.0/16网段的数据<br>iptables -A FORWARD -s 192.168.1.11 -j REJECT<br>iptables -A FORWARD -s 192.168.0.0/16 -j ACCEPT<br>说明：注意要把拒绝的放在前面</p></li><li><p>丢弃从外网接口（eth1）进入防火墙本机的源地址为私网地址的数据包<br>iptables -A INPUT -i eth1 -s 192.168.0.0/16 -j DROP<br>iptables -A INPUT -i eth1 -s 172.16.0.0/12 -j DROP<br>iptables -A INPUT -i eth1 -s 10.0.0.0/8 -j DROP</p></li><li><p>封堵网段（192.168.1.0/24），两个两个小时候解封<br>iptables -I INPUT -s 192.168.1.0/24 -j DROP<br>iptabls -I FORWARD -s 192.168.1.0/24 -j DROP<br>at now 2 hours at&gt;iptables -D INPUT 1 at&gt; iptables -D FORWARD 1</p></li><li><p>只允许管理员从202.13.0.0/16网段使用SSH远程登录防火墙主机<br>iptables -A INPUT -p tcp –dport 22 -s 202.13.0.0/16 -j ACCEPT<br>iptables -A INPUT -p tcp –dport 22 -j DROP</p></li><li><p>允许本机开放从tcp端口20-1024提供的应用服务<br>iptables -A INPUT -p tcp –dport 20:1024 -j ACCEPT<br>iptables -A OUTPUT -p tcp –sport 20:1024 -j ACCEPT</p></li><li><p>允许转发来自192.168.0.0/16局域网段的DNS解析请求数据包<br>iptables -A FORWARD -s 192.168.0.0/16 -p udp –dport 53 -j ACCEPT<br>iptables -A FORWARD -d 192.168.0.0/16 -p udp –sport 53 -j ACCEPT</p></li><li><p>禁止其他主机ping防火墙主机，但是允许从防火墙上ping其他主机<br>iptables -I INPUT -p icmp –icmp-type Echo-Request -j DROP<br>iptables -I INPUT -p icmp –icmp-type Echo-Reply -j ACCEPT<br>iptables -I INPUT -p icmp –icmp-type destination-Unreachable -j ACCEPT</p></li><li><p>禁止转发来自MAC地址 00:0c:29:27:55:3F的主机的数据包<br>iptables -A FORWARD -m mac –mac-source 00:0c:29:27:55:3F -j DROP</p></li><li><p>允许防火墙主机对外开放TCP端口20、21、25、110以及被动模式FTP端口1250-1280<br>iptables -A INPUT -p tcp -m multiport –dport 20,21,25,110,1250:1280 -j ACCEPT</p></li><li><p>禁止转发源地址IP为192.168.1.20-192.168.1.99的TCP数据包<br>iptables -A FORWARD -p tcp -m iprange –src-range 192.168.1.20-192.168.1.99 -j DROP</p></li><li><p>禁止转发与正常TCP连接无关的非–syn请求数据包<br>iptables -A FORWARD -m state –state NEW -p tcp !–syn -j DROP<br>说明：“-m state”表示数据包的连接状态，“NEW”表示与任何连接无关</p></li><li><p>拒绝访问防火墙的新数据包，但允许响应连接或与已有连接相关的数据包<br>iptables -A INPUT -p tcp -m state –state NEW -j DROP<br>iptables -A INPUT -p tcp -m state –state ESTABLISHED,RELATED -j ACCEPT</p></li><li><p>只开放本机的Web服务（80）、FTP（20、21、20450-20480），放行外部主机发往服务器其他端口的应答数据包，将其他入栈数据包均予以丢弃处理<br>iptables -I INPUT -p tcp -m multiport –dport 20,21,80 -j ACCEPT<br>iptables -I INPUT -p tcp –dport 20450-20480 -j ACCEPT<br>iptables -I INPUT -p tcp -m state –state ESTABLISHED -j ACCEPT<br>iptables -P INPUT DROP</p></li></ol><h3 id="常用iptables规则"><a href="#常用iptables规则" class="headerlink" title="常用iptables规则"></a>常用iptables规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"># 1. 删除所有现有规则</span><br><span class="line"></span><br><span class="line">iptables -F</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 2. 设置默认的 chain 策略</span><br><span class="line"></span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line"></span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line"></span><br><span class="line">iptables -P OUTPUT DROP</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 3. 阻止某个特定的 IP 地址</span><br><span class="line"></span><br><span class="line">#BLOCK_THIS_IP&#x3D;&quot;x.x.x.x&quot;</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -s &quot;$BLOCK_THIS_IP&quot; -j DROP</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 4. 允许全部进来的（incoming）SSH</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 5. 只允许某个特定网络进来的 SSH</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0&#x2F;24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 6. 允许进来的（incoming）HTTP</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 7. 多端口（允许进来的 SSH、HTTP 和 HTTPS）</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 8. 允许出去的（outgoing）SSH</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 9. 允许外出的（outgoing）SSH，但仅访问某个特定的网络</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp -d 192.168.101.0&#x2F;24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 10. 允许外出的（outgoing） HTTPS</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 11. 对进来的 HTTPS 流量做负载均衡</span><br><span class="line"></span><br><span class="line">#iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.101:443</span><br><span class="line"></span><br><span class="line">#iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 1 -j DNAT --to-destination 192.168.1.102:443</span><br><span class="line"></span><br><span class="line">#iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 2 -j DNAT --to-destination 192.168.1.103:443</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 12. 从内部向外部 Ping</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p icmp --icmp-type echo-reply -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 13. 从外部向内部 Ping</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 14. 允许环回（loopback）访问</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -o lo -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 15. 允许 packets 从内网访问外网</span><br><span class="line"></span><br><span class="line"># if eth1 is connected to external network (internet)</span><br><span class="line"></span><br><span class="line"># if eth0 is connected to internal network (192.168.1.x)</span><br><span class="line"></span><br><span class="line">iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 16. 允许外出的  DNS</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 17. 允许 NIS 连接</span><br><span class="line"></span><br><span class="line"># rpcinfo -p | grep ypbind ; This port is 853 and 850</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -p tcp --dport 111 -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -p udp --dport 111 -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -p tcp --dport 853 -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -p udp --dport 853 -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -p tcp --dport 850 -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -p udp --dport 850 -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 18. 允许某个特定网络 rsync 进入本机</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp -s 192.168.101.0&#x2F;24 --dport 873 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp --sport 873 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 19. 仅允许来自某个特定网络的 MySQL 的链接</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp -s 192.168.200.0&#x2F;24 --dport 3306 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp --sport 3306 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 20. 允许 Sendmail 或 Postfix</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -i eth0 -p tcp --dport 25 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">iptables -A OUTPUT -o eth0 -p tcp --sport 25 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 21. 允许 IMAP 和 IMAPS</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp --dport 143 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp --sport 143 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp --dport 993 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp --sport 993 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 22. 允许 POP3 和 POP3S</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp --dport 110 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp --sport 110 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp --dport 995 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp --sport 995 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 23. 防止 DoS 攻击</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -m limit --limit 25&#x2F;minute --limit-burst 100 -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 24. 设置 422 端口转发到 22 端口</span><br><span class="line"></span><br><span class="line">#iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22</span><br><span class="line"></span><br><span class="line">#iptables -A INPUT -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 25. 为丢弃的包做日志（Log）</span><br><span class="line"></span><br><span class="line">iptables -N LOGGING</span><br><span class="line"></span><br><span class="line">iptables -A INPUT -j LOGGING</span><br><span class="line"></span><br><span class="line">iptables -A LOGGING -m limit --limit 2&#x2F;min -j LOG --log-prefix &quot;IPTables Packet Dropped: &quot; --log-level 7</span><br><span class="line"></span><br><span class="line">iptables -A LOGGING -j DROP</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/sunsky303/p/12327863.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/sunsk
      
    
    </summary>
    
    
    
      <category term="linux" scheme="https://chpiter.net/tags/linux/"/>
    
      <category term="iptables" scheme="https://chpiter.net/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>Nginx优化长连接</title>
    <link href="https://chpiter.net/2020/03/13/Nginx%E4%BC%98%E5%8C%96%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <id>https://chpiter.net/2020/03/13/Nginx%E4%BC%98%E5%8C%96%E9%95%BF%E8%BF%9E%E6%8E%A5/</id>
    <published>2020-03-13T02:04:04.000Z</published>
    <updated>2020-03-13T10:24:43.055Z</updated>
    
    <content type="html"><![CDATA[<p>引用：</p><ul><li><a href="https://www.cnblogs.com/sunsky303/p/10648861.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunsky303/p/10648861.html</a></li></ul><h1 id="一、nginx之tcp-nooush、tcp-nodelay、snefile"><a href="#一、nginx之tcp-nooush、tcp-nodelay、snefile" class="headerlink" title="一、nginx之tcp_nooush、tcp_nodelay、snefile"></a>一、nginx之tcp_nooush、tcp_nodelay、snefile</h1><h2 id="1-TCP-NODELAY"><a href="#1-TCP-NODELAY" class="headerlink" title="1. TCP_NODELAY"></a>1. TCP_NODELAY</h2><p>怎么强制socket在它的缓冲区里发送数据？<br>一个解决方案是TCP堆栈的TCP_NODELAY选项。这样就可以使缓冲区中的数据立即发送出去。<br>Nginx的TCP_NODELAY选项使得在打开一个新的socket时增加了TCP_NODELAY选项。但这时会造成一种情况：<br>终端应用程序每产生一次操作就会发送一个包，而典型情况下下一个包会拥有一个字节的数据以及40个字节长的包头，于是产生4000%的过载，很轻易的能令网络发生拥塞。<strong>为了避免这种情况，TCP堆栈实现了等待数据0.2秒钟，因此操作后它不会发送一个数据包，而是将这段时间内的数据打成一个大的包。这一机制是由Nagle算法保证。</strong></p><p>Nagle化后来成了一种标准并且立即在因特网上得以实现。它现在已经成为默认配置了，但是有些场合下把这一选项关掉也是合乎需要的。现在假设某个应用程序发出了一个请求，希望发送小块数据。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。<br>如果我们马上发送数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。如果请求立即发出那么响应时间也会快一些。**以上操作可以通过设置套接字的TCP_NODELAY = on 选项来完成，这样就禁用了Nagle算法。（不需要等待0.2s）</p><h2 id="2-TCP-NOPUSH"><a href="#2-TCP-NOPUSH" class="headerlink" title="2. TCP_NOPUSH"></a>2. TCP_NOPUSH</h2><p>在nginx中，tcp_nopush配置和tcp_nodelay“互斥”。<strong>它可以配置一次发送数据的包大小。也就是说，它不是按时间累计0.2秒后发送包，而是当宝累计到一定大小后就发送。</strong><br><strong>注：在nginx中，tcp_nopush必须和sendfile搭配使用。</strong></p><h2 id="3-sendfile"><a href="#3-sendfile" class="headerlink" title="3. sendfile"></a>3. sendfile</h2><p>现在流行的web服务器里面都提供sendfile选项用来提高服务器性能，那到底sendfile是什么，怎么影响性能的呢？<br>sendfile实际上是linux2.0+以后推出的一个系统调用，web服务器可以通过调整自身的配置来决定是否利用sendfile这个系统调用。先来看一下不用sendfile的传统网络传输过程：<br>read(file,tmp_buf,len);<br>write(socket,rmp_buf,len);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬盘 &gt;&gt; kernel buffer &gt;&gt; user buffer &gt;&gt; kernel socket buffer &gt;&gt; 协议栈</span><br></pre></td></tr></table></figure><p>1）一般来说一个网络应用是通过读硬盘数据，然后写数据到socket来完成网络传输的。上面的2行代码解释了这一点，不过上面2行简单的代码掩盖了低层的很多操作。来看看低层是怎么执行的：</p><ol><li>系统调用read()产生一个上下文切换，从user mode切换到kernel mode，然后DMA执行拷贝，把文件数据从硬盘读到一个kernel buffer里。</li><li>数据从kernel buffer拷贝到user mode，然后系统调用read()返回，这时又产生一个上下文切换：从kernel mode切换到user mode。</li><li>系统调用write()产生一个上下文切换：从user mode切换到kernel mode，然后把步骤2读到user buffer的数据拷贝到kernel buffer（数据第2次拷贝到kernel buffer），不过这次是个不同的kernel buffer，这个buffer和socket相关联。</li><li>系统调用write()返回，产生一个上下文切换：从kernel mode切换到user mode（第4次切换了），然后DMA从kernel buffer拷贝数据到协议产（第4次拷贝了）。<br>上面4个步骤有4次切换，4次拷贝，我们发现如果能减少切换次数和拷贝次数将会有效提升性能。在kernel2.0+版本中，系统调用sendfile()就是用来简化上面步骤提升性能的。<br><strong>sendfile()不但能减少切换次数，还能减少拷贝次数。</strong><br>2）再来看下sendfile()来进行网络传输的过程：<br>sendfile(socket,file,len);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">硬盘 &gt;&gt; kernel buffer（快速拷贝到kernel socket buffer） &gt;&gt; 协议栈</span><br></pre></td></tr></table></figure></li><li>系统调用sendfile()通过DMA把硬盘数据拷贝到kernel buffer，然后数据被kernel直接拷贝到另外一个socket相关的kernel buffer。这里没有user mode和kernel mode之间的切换，在kernel中直接完成了一个buffer到另一个buffer的拷贝。</li><li>DMA把数据从kernel buffer直接拷贝给协议栈，没有切换，也不需要数据从user mode拷贝到kernel mode，因为数据就在kernel中。<br>步骤减少了，切换减少了，拷贝减少了，自然性能就提升了。这就是为什么说在Nginx配置文件里打开sendfile on选项能提高web server性能的原因。</li></ol><p>  <strong>综上，这三个参数都应该配置成on：sendfile on;tcp_nopush on;tcp_nodelay on;</strong></p><h1 id="二、-nginx长连接-keepalive"><a href="#二、-nginx长连接-keepalive" class="headerlink" title="二、 nginx长连接-keepalive"></a>二、 nginx长连接-keepalive</h1><p>当时用nginx作为反向代理时，为了支持长连接，需要做到两点：</p><ul><li>从client到nginx的连接是长连接</li><li>从nginx到server的连接是长连接</li></ul><h2 id="1、保持和client的长连接："><a href="#1、保持和client的长连接：" class="headerlink" title="1、保持和client的长连接："></a>1、保持和client的长连接：</h2><p>默认情况下，nginx已经自动开启了对client连接的keep alive支持（同时client发送的HTTP请求要求keep alive）。一般场景可以直接使用，但是对于一些比较特殊的场景，还是有必要调整个别参数（keepalive_timeout和keepalive_requests）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    keepalive_timeout 120s 120s;</span><br><span class="line">    keepalive_requests 10000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）keepalive_timeout</p><ol><li>第一个参数：设置keep-alive客户端连接在服务器端保持开启的超时值（默认75s）；值为0会禁用keep-alive客户端连接；</li><li>第二个参数：可选，在响应的header域中设置一个值“Keep-Alive: timeout=time”；通常可以不用设置；<br>注：keepalive_timeout默认75s，一般情况下够用，对于一些请求比较大的内部服务器通讯的场景，适当加大为120s或者300s；</li></ol><p>2）keepalive_requests<br>keepalive_requests指令用于<strong>设置一个keep-alive连接上可以服务的请求的最大数量，当最大请求数量达到时，连接被关闭。默认是100</strong>。这个参数的真实含义，是指一个keep alive建立之后，nginx就会为这个连接设置一个计数器，记录这个keep alive的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则nginx会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接。<br>大多数情况下当QPS（每秒请求数）不是很高时，默认值100凑活够用。但是，对于一些QPS比较高（比如超过10000QPS，甚至达到3k，5k设置更高）的场景，默认的100就显得太低。<br>简单计算一下，QPS=10000时，客户端每秒发送10000个请求（通常建立有多个长连接），每个连接只能最多跑1000次请求，意味着平均每秒钟重新新建100个连接。因此，就会发现有大量的TIME_WAIT的socket连接（即使此时keep alive已经在client和nginx之间生效）。<strong>因为对于QPS较高的场景，非常有必要加大这个参数，以避免大量连接被生成再抛弃的情况，减少TIME_WAIT。</strong></p><h2 id="2、保持和server的长连接"><a href="#2、保持和server的长连接" class="headerlink" title="2、保持和server的长连接"></a>2、保持和server的长连接</h2><p>为了让nginx和后端server（nginx成为upstream）之间保持长连接，典型设置如下：（<strong>默认nginx访问后端都是用的短连接（HTTP1.0），一个请求来了，nginx新开一个端口和后端建立连接，后端执行完毕后主动关闭该链接</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream  BACKEND &#123;</span><br><span class="line">        server   192.168.0.1：8080  weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">        server   192.168.0.2：8080  weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">        keepalive 300;        &#x2F;&#x2F; 这个很重要！</span><br><span class="line">    &#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 8080 default_server;</span><br><span class="line">        server_name &quot;&quot;;</span><br><span class="line">        location &#x2F;  &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;BACKEND;</span><br><span class="line">            proxy_set_header Host  $Host;</span><br><span class="line">            proxy_set_header x-forwarded-for $remote_addr;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            add_header Cache-Control no-store;</span><br><span class="line">            add_header Pragma  no-cache;</span><br><span class="line">            proxy_http_version 1.1;         &#x2F;&#x2F; 这两个最好也设置</span><br><span class="line">            proxy_set_header Connection &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）location中有两个参数需要设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F;  &#123;</span><br><span class="line">            proxy_http_version 1.1; &#x2F;&#x2F; 这两个最好也设置</span><br><span class="line">            proxy_set_header Connection &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTTP协议中对长连接的支持是从1.1版本之后才有的，因为最好通过proxy_http_version指令设置为“1.1；<br>而“Connection” header应该被清理。清理的意思，我的理解，是清理从client过来的http header，因为即使client和nginx之间是短连接，nginx和upstream之间也是可以开启长连接的。这种情况下必须清理来自client请求中的“Connection” header。</p><p>2）upstream中的keepalive设置<br>次数keepalive的含义不是开启、关闭长连接的开关，也不是用来设置超时的timeout；更不是设置长连接池的最大连接数。官方解释：</p><ol><li>The connections parameter sets the maximum number of idle keepalive connections to upstream servers connections（<strong>设置到upstream服务器的空闲keepalive连接的最大数量</strong>）</li><li>When this number is exceeded, the least recently used connections are closed. （<strong>当这个数量被突破时，最近使用最少的连接将被关闭</strong>）</li><li>It should be particularly noted that the keepalive directive does not limit the total number of connections to upstream servers that an nginx worker process can open.（<strong>特别提醒：keepalive指令不会限制一个nginx worker进程到upstream服务器连接的总数量</strong>）<br>我们先假设一个场景：有一个HTTP服务，作为upstream服务器接收请求，响应时间为100毫秒。如果要达到10000 QPS的性能，就需要在nginx和upstream服务器之间建立大约1000条HTTP连接。nginx为此建立连接池，然后请求过来时为每个请求分配一个连接，请求结束时回收连接到连接池中，连接的状态也就更改为idle。我们再假设这个upstream服务器的keepalive参数值比较小，比如常见的10：<br>A、假设请求和响应是均匀而平稳的，那么这1000条连接应该都是一放回连接池就立即被后续请求申请使用，线程池中的idle线程会非常少，趋近于零，不会造成连接数量反复震荡。<br>B、现实中请求和响应不可能平稳，我们以10毫秒为一个单位，来看连接的情况（逐一场景是1000个线程+100毫秒响应时间，每秒有10000个请求完成），我们假设应答始终都是平稳的，只是请求不平稳，第一个10毫秒只有50，第二个10毫秒有150：</li><li>下一个10毫秒，有100个连接结束请求回收连接到连接池，但是假设此时请求不均匀10毫秒内没有预计的100个请求进来，而是只有50个请求。注意此时连接池回收了100个连接又分配出去50个连接，因此连接池内有50个空闲连接。</li><li>然后注意看keepalive=10的设置，这意味着连接池中最多容许保留有10个控线连接。因为nginx不得不将这50个空闲连接中的40个关闭，只保留10个。</li><li>再下一个10毫秒，有150个请求进来，有100个请求结束任务释放连接。150-100=50，孔雀50个连接，减掉前面连接池保留的10个空闲连接，nginx不得不新建40个新连接来满足要求。<br>C、同样，如果假设响应不均衡也会出现上面的连接数波动情况。</li></ol><p>造成连接数量反复震荡的一个推手，就是keepalive这个最大空闲连接数。毕竟连接池中的1000个连接在频繁利用时，出现短时间内多余10个空闲连接的概率是在太高。<strong>因此为了避免出现上面的连接震荡，必须考虑加大这个参数</strong>，比如上面的场景如果将keepalive设置为100或者200，就可以非常有效的缓冲请求和应答不均。</p><p>总结：<br>keepalive这个参数一定要小心设置，尤其对于QPS比较高的场景，推荐先做一下估算（<strong>容量规划</strong>），根据QPS和平均响应时间答题能计算出需要的长连接的数量。比如前面1000QPS和100毫秒响应时间就可以推算出需要的长连接数量大概是1000.然后将keepalive设置为这个长连接数量的10%到30%。比较懒的同学，可以直接设置为keepalive=1000之类的，一般都是OK的。</p><h2 id="3、综上，出现大量TIME-WAIT的情况："><a href="#3、综上，出现大量TIME-WAIT的情况：" class="headerlink" title="3、综上，出现大量TIME_WAIT的情况："></a>3、综上，出现大量TIME_WAIT的情况：</h2><p>1）导致nginx端出现大量TIME_WAIT的情况有两种：</p><ul><li>keepalive_requests设置比较小，高并发下超过此值后nginx会强制关闭和客户端保持的keepalive长连接；（主动关闭连接后导致nginx出现TIME_WAIT）</li><li>keepalive设置的比较小（空闲数太小），导致高并发下nginx会频繁的出现连接数震荡（超过该值会关闭连接），不停的关闭、开启和后端server保持的keepalive长连接<br>2）导致后端server端出现大量TIME_WAIT的情况：<br>nginx没有打开和后端的长连接，即：没有设置proxy_http_version 1.1和proxy_set_header Connection “”；从而导致后端server每次关闭连接，高并发下就会出现server端出现大量TIME_WAIT。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/sunsky303/p/10648861.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/sunsk
      
    
    </summary>
    
    
    
      <category term="nginx" scheme="https://chpiter.net/tags/nginx/"/>
    
      <category term="keepalive" scheme="https://chpiter.net/tags/keepalive/"/>
    
  </entry>
  
  <entry>
    <title>清空收藏夹</title>
    <link href="https://chpiter.net/2020/03/12/%E6%B8%85%E7%A9%BA%E6%94%B6%E8%97%8F%E5%A4%B9/"/>
    <id>https://chpiter.net/2020/03/12/%E6%B8%85%E7%A9%BA%E6%94%B6%E8%97%8F%E5%A4%B9/</id>
    <published>2020-03-12T10:17:19.000Z</published>
    <updated>2020-03-13T01:23:49.142Z</updated>
    
    <content type="html"><![CDATA[<pre><code>“收藏即看过”！清理收藏夹内容，转移至博客，重新学习一遍！</code></pre><p>测试数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;“收藏即看过”！
清理收藏夹内容，转移至博客，重新学习一遍！&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试数据&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="学习" scheme="https://chpiter.net/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>长连接KeepAlive</title>
    <link href="https://chpiter.net/2020/03/11/%E9%95%BF%E8%BF%9E%E6%8E%A5KeepAlive/"/>
    <id>https://chpiter.net/2020/03/11/%E9%95%BF%E8%BF%9E%E6%8E%A5KeepAlive/</id>
    <published>2020-03-11T03:11:08.000Z</published>
    <updated>2020-03-12T11:19:31.547Z</updated>
    
    <content type="html"><![CDATA[<p>引用：</p><ul><li><a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">https://www.cnblogs.com/gotodsp/p/6366163.html</a></li></ul><h1 id="1-HTTP协议和TCP-IP协议的关系"><a href="#1-HTTP协议和TCP-IP协议的关系" class="headerlink" title="1. HTTP协议和TCP/IP协议的关系"></a>1. HTTP协议和TCP/IP协议的关系</h1><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址的问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠地，面向连接的。</p><h1 id="2-如何理解HTTP协议是无状态的"><a href="#2-如何理解HTTP协议是无状态的" class="headerlink" title="2. 如何理解HTTP协议是无状态的"></a>2. 如何理解HTTP协议是无状态的</h1><p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p><h1 id="3-什么时候长连接、短连接？"><a href="#3-什么时候长连接、短连接？" class="headerlink" title="3. 什么时候长连接、短连接？"></a>3. 什么时候长连接、短连接？</h1><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如Javascript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。<br>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connecti:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。<br>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h2 id="3-1-TCP连接"><a href="#3-1-TCP连接" class="headerlink" title="3.1 TCP连接"></a>3.1 TCP连接</h2><p>当网络通信时采用TCP协议时，在真正的读写操作之前，客户端与服务器端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时可以释放这个连接。连接的建立依靠“三次握手，而释放则需要”四次握手，所以每个连接的建立都是需要资源消耗和时间消耗的。<br>经典的三次握手建立连接示意图：<br><img src="/images/keepalive-1.jpg" alt=""><br><img src="/images/593345-20170204231325729-1747734402.png" alt=""></p><p>经典的四次握手关闭连接示意图：<br><img src="/images/keepalive-2.jpg" alt=""><br><img src="/images/593345-20170204231344745-1817753534.jpg" alt=""></p><h2 id="3-2-TCP短连接"><a href="#3-2-TCP短连接" class="headerlink" title="3.2 TCP短连接"></a>3.2 TCP短连接</h2><p>模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在client/server间传递一次请求操作。<br>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。</p><h2 id="3-3-TCP长连接"><a href="#3-3-TCP长连接" class="headerlink" title="3.3 TCP长连接"></a>3.3 TCP长连接</h2><p>我们再模拟一次长连接的情况：client向server发起连接，server接受连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。<br>TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务器端检测到这种半开放的连接。<br>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文，根据客户端主机响应探测4个客户端状态：</p><ul><li>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重启。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</li><li>客户端崩溃已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li>客户端正常运行，但是服务器不可达。这种情况与第二种状态类似。</li></ul><h1 id="4-长连接和短连接的优点和缺点"><a href="#4-长连接和短连接的优点和缺点" class="headerlink" title="4. 长连接和短连接的优点和缺点"></a>4. 长连接和短连接的优点和缺点</h1><p>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接，这时候server端需要采取一些策略，比如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。<br>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户端请求频繁，将在TCP的建立和关闭操作上浪费较多的时间和带宽。<br>长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。<br>由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适合长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接数越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写时间发生的连接，这样可以避免一些恶意连接导致server端服务手段；如果条件再允许就可以以客户端为颗粒度，限制每个客户端的最大长连接，这样可以完全避免某个客户端连累后端服务。<br>短连接赋予服务器来说，管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上康菲时间和带宽。<br>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p><p>长连接短连接操作过程<br>短连接的操作步骤是：<br>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接<br>长连接的操作步骤是：<br>建立连接——数据传输…（保持连接）…数据传输——关闭连接<br>什么时候用长连接，短连接？  　　<br>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。<br>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p><p>http和socket之长连接和短连接区别<br><a href="http://www.jianshu.com/p/b68d2b26f5f4" target="_blank" rel="noopener">http://www.jianshu.com/p/b68d2b26f5f4</a></p><p>HTTP持久连接<br><a href="https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/gotodsp/p/6366163.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/gotodsp/
      
    
    </summary>
    
    
    
      <category term="tcp" scheme="https://chpiter.net/tags/tcp/"/>
    
      <category term="http" scheme="https://chpiter.net/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Nginx健康检查</title>
    <link href="https://chpiter.net/2020/03/11/Nginx%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/"/>
    <id>https://chpiter.net/2020/03/11/Nginx%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</id>
    <published>2020-03-11T01:30:34.000Z</published>
    <updated>2020-03-11T02:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>引用：</p><ul><li><a href="http://ningg.top/nginx-series-health-check/" target="_blank" rel="noopener">http://ningg.top/nginx-series-health-check/</a></li></ul><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>服务治理</strong>的一个重要任务是感知服务街店的变更，完成<strong>服务自动注册</strong>和<strong>异常节点的自动摘除</strong>。这就需要服务治理平台能够：<strong>及时</strong>，<strong>准确</strong>的感知service节点的健康状况。</p><h1 id="方案概述"><a href="#方案概述" class="headerlink" title="方案概述"></a>方案概述</h1><p>Nginx提供了三种服务健康检查方案：</p><ol><li>TCP层检查方案：定时与后端服务简历一条<strong>tcp连接</strong>，连接建立成功则认为服务节点是健康的；</li><li>HTTP层检查方案：TCP层检查有一定的局限性：<ol><li>很多HTTP服务是有状态的，端口处于listen状态并不能代表服务已经完全预热（可以对外提供服务）；</li><li>不能真实反映服务内部处理逻辑是否拥堵；</li><li>这时可以选择http层健康检查，会向服务发送一个http请求<strong>GET / HTTP/1.0\r\n\r\n</strong>，返回状态是2xx或3xx时认为后端服务正常；</li></ol></li><li>自定义方案：可根据下文描述自定义检查方案。</li></ol><h1 id="配置参数详解"><a href="#配置参数详解" class="headerlink" title="配置参数详解"></a>配置参数详解</h1><p>一个常用的健康检查配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check fall&#x3D;3 interval&#x3D;3000 rise&#x3D;2 timeout&#x3D;2000 type&#x3D;http;</span><br><span class="line">check_http_expect_alive http_2xx http_3xx ;</span><br><span class="line">check_http_send &quot;GET &#x2F;checkAlive HTTP&#x2F;1.0\r\n\r\n&quot; ;</span><br></pre></td></tr></table></figure><p>下面针对每个配置，进行详细介绍：</p><h2 id="check"><a href="#check" class="headerlink" title="check"></a>check</h2><p>check字段参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax: check interval&#x3D;milliseconds [fall&#x3D;count] [rise&#x3D;count] [timeout&#x3D;milliseconds] [default_down&#x3D;true|false] [type&#x3D;tcp|http|ssl_hello|mysql|ajp] [port&#x3D;check_port]</span><br><span class="line">Default: 如果没有配置参数，默认值是：interval&#x3D;30000 fall&#x3D;5 rise&#x3D;2 timeout&#x3D;1000 default_down&#x3D;true type&#x3D;tcp</span><br></pre></td></tr></table></figure><p>check字段各个参数含义如下：</p><ul><li>interval：向后端发送的健康检查包的间隔</li><li>fall(fall_count)：如果连续失败次数达到fall_count，服务器就被认为是down</li><li>rise(rise_count)：如果连续成功次数达到rise_count，服务器就被人为是up</li><li>timeout：后端健康请求的超时时间</li><li>default_down：设定初始时服务器的状态，如果是true，就说ing默认是down的，如果是false，就是up的。默认是true，也就是一开始服务器认为是不可用，要等健康检查包达到一定成功次数才会被认为是健康的</li><li>type：健康检查包的类型，<ul><li>tcp：简单的tcp连接，如果连接成功，就说明后端正常</li><li>ssl_hello：发送一个初始的SSL hello包并接受服务器的SSL hello包</li><li>http：发送HTTP请求，通过后端的回复包的状态来判断后端是否存活</li><li>mysql：向mysql服务器连接，通过接收服务器的greeting包来判断后端是否存活</li><li>ajp：向后端发送AJP协议的Cping包，通过接收Cpong包来判断后端是否存活</li><li>port：指定后端服务器的检查端口。可以指定不同于真实服务的后端服务器的端口，比如后端提供的是443端口的应用，你可以去检查80端口的状态来判断后端健康状况。默认是0，标识跟后端server提供真实服务的端口一样。</li></ul></li></ul><h2 id="check-http-expext-alive"><a href="#check-http-expext-alive" class="headerlink" title="check_http_expext_alive"></a>check_http_expext_alive</h2><p>check_http_expect_alive 指定主动健康检查时HTTP回复的成功状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax: check_http_expect_alive [ http_2xx | http_3xx | http_4xx | http_5xx ]</span><br><span class="line">Default: http_2xx | http_3xx</span><br></pre></td></tr></table></figure><h2 id="check-http-send"><a href="#check-http-send" class="headerlink" title="check_http_send"></a>check_http_send</h2><p>check_http_send 配置HTTP健康检查包发送的请求内容<br>为了减少传输数据量，推荐采用“HEAD”方法。当采用长连接进行健康检查时，需要在该指令中添加keep-alive请求头，如：“HEAD / HTTP/1.1\r\nConnection:keep-alive\r\n\r\n”。同时，在采用”GET“方法的情况下，请求uri的size不宜过大，确保可以在1个interval内传输完成，否则会被健康检查模块视为后端服务器或网络异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Syntax: check_http_send http_packet</span><br><span class="line">Default: &quot;GET &#x2F; HTTP&#x2F;1.0\r\n\r\n&quot;</span><br></pre></td></tr></table></figure><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream cluster1 &#123;</span><br><span class="line">        # simple round-robin</span><br><span class="line">        server 192.168.0.1:80;</span><br><span class="line">        server 192.168.0.2:80;</span><br><span class="line">        check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;5 timeout&#x3D;1000 type&#x3D;http;</span><br><span class="line">        check_http_send &quot;HEAD &#x2F; HTTP&#x2F;1.0\r\n\r\n&quot;;</span><br><span class="line">        check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">    &#125;</span><br><span class="line">    upstream cluster2 &#123;</span><br><span class="line">        # simple round-robin</span><br><span class="line">        server 192.168.0.3:80;</span><br><span class="line">        server 192.168.0.4:80;</span><br><span class="line">        check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;5 timeout&#x3D;1000 type&#x3D;http;</span><br><span class="line">        check_keepalive_requests 100;</span><br><span class="line">        check_http_send &quot;HEAD &#x2F; HTTP&#x2F;1.1\r\nConnection: keep-alive\r\n\r\n&quot;;</span><br><span class="line">        check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        location &#x2F;1 &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;cluster1;</span><br><span class="line">        &#125;</span><br><span class="line">        location &#x2F;2 &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;cluster2;</span><br><span class="line">        &#125;</span><br><span class="line">        location &#x2F;status &#123;</span><br><span class="line">            check_status;</span><br><span class="line">            access_log   off;</span><br><span class="line">            allow SOME.IP.ADD.RESS;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ningg.top/nginx-series-health-check/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ningg.top/nginx-series-healt
      
    
    </summary>
    
    
    
      <category term="nginx" scheme="https://chpiter.net/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx路径匹配</title>
    <link href="https://chpiter.net/2020/03/11/Nginx%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D/"/>
    <id>https://chpiter.net/2020/03/11/Nginx%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D/</id>
    <published>2020-03-11T01:04:51.000Z</published>
    <updated>2020-03-11T01:28:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>引用：</p><ul><li><a href="http://ningg.top/nginx-series-practice-location/" target="_blank" rel="noopener">http://ningg.top/nginx-series-practice-location/</a></li></ul><h1 id="1-目标"><a href="#1-目标" class="headerlink" title="1. 目标"></a>1. 目标</h1><p>nginx反向代理，路径映射过程是什么？如何配置路径映射规则？</p><h1 id="2-location路径匹配"><a href="#2-location路径匹配" class="headerlink" title="2. location路径匹配"></a>2. location路径匹配</h1><h2 id="2-1-匹配规则"><a href="#2-1-匹配规则" class="headerlink" title="2.1 匹配规则"></a>2.1 匹配规则</h2><p>location路径正则匹配<br>|符号|说明|<br>|—|—|<br>|<del>|正则匹配，区分大小写|<br>|</del>*|正则匹配，不区分大小写|<br>|^~|普通字符匹配，如果该选项匹配，则，只匹配该选项，不再向下匹配其他选项|<br>|=|普通字符匹配，精确匹配|<br>|@|定义一个命名的location，用于内部定向，例如error_page,try_files|</p><h2 id="2-2-匹配优先级"><a href="#2-2-匹配优先级" class="headerlink" title="2.2 匹配优先级"></a>2.2 匹配优先级</h2><p>路径匹配，优先级：（跟location的书写顺序关系不大）</p><ol><li><strong>精确匹配</strong>：=前缀的指令严格匹配这个查询。如果找到，停止搜索；</li><li><strong>普通字符匹配</strong>：所有剩下的常规字符串，最长的匹配。如果这个匹配使用^~前缀，搜索停止；</li><li><strong>正则匹配</strong>：正则表达式，在配置文件中定义的顺序，匹配到一个结果，搜索停止；</li><li><strong>默认匹配</strong>：如果第3条规则产生匹配的话，结果被使用。否则，如同从第2条规则被使用。</li></ol><h2 id="2-3-举例"><a href="#2-3-举例" class="headerlink" title="2.3 举例"></a>2.3 举例</h2><p>通过一个实例，简单说明一下匹配优先级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">location  &#x3D; &#x2F; &#123;</span><br><span class="line">  # 精确匹配 &#x2F; ，主机名后面不能带任何字符串</span><br><span class="line">  [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location  &#x2F; &#123;</span><br><span class="line">  # 因为所有的地址都以 &#x2F; 开头，所以这条规则将匹配到所有请求</span><br><span class="line">  # 但是正则和最长字符串会优先匹配</span><br><span class="line">  [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location &#x2F;documents&#x2F; &#123;</span><br><span class="line">  # 匹配任何以 &#x2F;documents&#x2F; 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location ~ &#x2F;documents&#x2F;Abc &#123;</span><br><span class="line">  # 匹配任何以 &#x2F;documents&#x2F; 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration CC ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location ^~ &#x2F;images&#x2F; &#123;</span><br><span class="line">  # 匹配任何以 &#x2F;images&#x2F; 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span><br><span class="line">  [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  # 匹配所有以 gif,jpg或jpeg 结尾的请求</span><br><span class="line">  # 然而，所有请求 &#x2F;images&#x2F; 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</span><br><span class="line">  [ configuration E ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location &#x2F;images&#x2F; &#123;</span><br><span class="line">  # 字符匹配到 &#x2F;images&#x2F;，继续往下，会发现 ^~ 存在</span><br><span class="line">  [ configuration F ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location &#x2F;images&#x2F;abc &#123;</span><br><span class="line">  # 最长字符匹配到 &#x2F;images&#x2F;abc，继续往下，会发现 ^~ 存在</span><br><span class="line">  # F与G的放置顺序是没有关系的</span><br><span class="line">  [ configuration G ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location ~ &#x2F;images&#x2F;abc&#x2F; &#123;</span><br><span class="line">  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</span><br><span class="line">    [ configuration H ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location ~* &#x2F;js&#x2F;.*&#x2F;\.js</span><br></pre></td></tr></table></figure><p>按照上面的location写法，以下的匹配示例成立：</p><ol><li>/ -&gt; config A：精确完全匹配，即使/index.html也匹配不了</li><li>/downloads/download.html -&gt; config B：匹配B以后，往下没有任何匹配，采用B</li><li>/images/1.gif -&gt; configuration D：匹配到F，往下匹配到D，停止往下</li><li>/images/abc/def -&gt; config D：最长匹配到G，往下匹配D，停止往下你可以看到 任何以/images/开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序</li><li>/documents/document.html -&gt; config C：匹配到C，往下没有任何匹配，采用C</li><li>/documents/1.jpg -&gt; configuration E：匹配到C，往下正则匹配到E</li><li>/documents/Abc.jpg -&gt; config CC：最长匹配到C，往下正则顺序匹配到CC，不会往下到E</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ningg.top/nginx-series-practice-location/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ningg.top/nginx-series-
      
    
    </summary>
    
    
    
      <category term="nginx" scheme="https://chpiter.net/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置</title>
    <link href="https://chpiter.net/2020/03/10/Nginx%E9%85%8D%E7%BD%AE/"/>
    <id>https://chpiter.net/2020/03/10/Nginx%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-10T09:48:36.000Z</published>
    <updated>2020-03-11T01:05:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看Nginx配置"><a href="#查看Nginx配置" class="headerlink" title="查看Nginx配置"></a>查看Nginx配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line">nginx version: nginx&#x2F;1.8.0</span><br><span class="line">built by clang 7.0.0 (clang-700.0.72)</span><br><span class="line">built with OpenSSL 1.0.2d 9 Jul 2015</span><br><span class="line">TLS SNI support enabled</span><br><span class="line"> </span><br><span class="line">configure arguments:</span><br><span class="line">--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx&#x2F;1.8.0</span><br><span class="line">--with-http_ssl_module</span><br><span class="line">--with-pcre</span><br><span class="line">--with-ipv6</span><br><span class="line">--sbin-path&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;nginx&#x2F;1.8.0&#x2F;bin&#x2F;nginx</span><br><span class="line">--with-cc-opt&#x3D;&#39;-I&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;pcre&#x2F;8.37&#x2F;include -I&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openssl&#x2F;1.0.2d_1&#x2F;include&#39;</span><br><span class="line">--with-ld-opt&#x3D;&#39;-L&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;pcre&#x2F;8.37&#x2F;lib -L&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;openssl&#x2F;1.0.2d_1&#x2F;lib&#39;</span><br><span class="line">--conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">--pid-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx.pid</span><br><span class="line">--lock-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx.lock</span><br><span class="line">--http-client-body-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;client_body_temp</span><br><span class="line">--http-proxy-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;proxy_temp</span><br><span class="line">--http-fastcgi-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;fastcgi_temp</span><br><span class="line">--http-uwsgi-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;uwsgi_temp</span><br><span class="line">--http-scgi-temp-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;run&#x2F;nginx&#x2F;scgi_temp</span><br><span class="line">--http-log-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</span><br><span class="line">--error-log-path&#x3D;&#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log</span><br><span class="line">--with-http_gzip_static_module</span><br></pre></td></tr></table></figure><p>注意上面的几个配置：</p><ul><li>–conf-path : /usr/local/etc/nginx/nginx.conf 配置文件</li><li>–http-log-path：访问日志</li><li>–error-log-path：错误日志</li></ul><h1 id="nginx-conf配置文件"><a href="#nginx-conf配置文件" class="headerlink" title="nginx.conf配置文件"></a>nginx.conf配置文件</h1><p>前面我们知道了，/usr/local/etc/nginx/nginx.conf 是nginx服务运行过程中的具体配置文件<br>这一部分，我们将通过剖析nginx.conf文件，弄清下面几点：</p><ol><li>设置端口？</li><li>开启日志？修改日志存储路径？</li><li>配置反向代理映射规则？</li></ol><h2 id="文件内部结构"><a href="#文件内部结构" class="headerlink" title="文件内部结构"></a>文件内部结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"> </span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line">  </span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"> </span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"> </span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"> </span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"> </span><br><span class="line">    #gzip  on;</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"> </span><br><span class="line">        #charset koi8-r;</span><br><span class="line"> </span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"> </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"> </span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"> </span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"> </span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"> </span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"> </span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"> </span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"> </span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"> </span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line">    include servers&#x2F;*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx.conf文件内部结构：</p><ol><li>worker_processes</li><li>error_log</li><li>events</li><li>http<ol><li>access_log</li><li>server<ol><li>listen</li><li>server_name</li><li>access_log</li><li>location<br>注：https时，上面的server配置略有不同。</li></ol></li></ol></li></ol><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>系统设计时，动态资源、静态资源，要在url上能够区分出来，这样才能使用nginx为静态资源提供单独的映射关系。<br>举例：下面就是动静资源分离的简单配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root &#x2F;data&#x2F;www;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    location &#x2F;images&#x2F; &#123;</span><br><span class="line">        root &#x2F;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态资源"><a href="#动态资源" class="headerlink" title="动态资源"></a>动态资源</h2><p>对于动态资源，nginx一般会把request转发到相应的服务器。<br>举例：下面把动态资源转发到其他服务器，静态资源直接指向本地。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:8080&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    location ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">        root &#x2F;data&#x2F;images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，location使用了process_pass配置，当proxy_pass指向多个ip地址时，可以使用 server group 配置，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com       weight&#x3D;5;</span><br><span class="line">    server backend2.example.com:8080;</span><br><span class="line">    server unix:&#x2F;tmp&#x2F;backend3;</span><br><span class="line"> </span><br><span class="line">    server backup1.example.com:8080   backup;</span><br><span class="line">    server backup2.example.com:8080   backup;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;查看Nginx配置&quot;&gt;&lt;a href=&quot;#查看Nginx配置&quot; class=&quot;headerlink&quot; title=&quot;查看Nginx配置&quot;&gt;&lt;/a&gt;查看Nginx配置&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
    
      <category term="nginx" scheme="https://chpiter.net/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx原理</title>
    <link href="https://chpiter.net/2020/03/10/Nginx%E5%8E%9F%E7%90%86/"/>
    <id>https://chpiter.net/2020/03/10/Nginx%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-10T02:39:25.000Z</published>
    <updated>2020-03-10T03:19:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>引用：</p><ul><li><a href="http://ningg.top/nginx-series-principle/" target="_blank" rel="noopener">http://ningg.top/nginx-series-principle/</a></li></ul><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="Nginx的进程模型"><a href="#Nginx的进程模型" class="headerlink" title="Nginx的进程模型"></a>Nginx的进程模型</h2><p><img src="/images/nginx-multi-progress-model.png" alt=""><br>Nginx服务器，正常运行过程中：</p><ol><li><strong>多进程</strong>：1个Master进程、多个Worker进程；</li><li><strong>Master进程</strong>：管理多个Worker进程：<ol><li>对外接口：接收<strong>外部操作</strong>信号</li><li>对内转发：根据<strong>外部操作</strong>的不同，通过<strong>信号</strong>管理Worker</li><li>监控：监控Worker进程的运行状态，Worker进程异常终止后，自动重启Worker进程</li></ol></li><li><strong>Worker</strong>进程：所有Worker进程都是平等的：<ol><li>实际处理：网络请求，又Worker进程处理；</li><li>Worker进程数量：在nginx.conf中配置，一般设置为<strong>CPU核心数</strong>，充分利用CPU资源，同时避免进程数量过多，避免进程之间竞争CPU资源，增加上下文切换的损耗。</li></ol></li></ol><p>思考：</p><ol><li>请求是连接到Nginx，Master进程负责处理和转发？</li><li>如何选定哪个Worker进程处理请求？请求的处理结果，是否还要经过Master进程？</li></ol><p><img src="/images/nginx-master-worker-details.png" alt=""></p><p>HTTP连接建立和请求处理过程：</p><ol><li>Nginx启动时，Master进程，加载配置文件；</li><li>Master进程，初始化监听的socket；</li><li>Master进程，fork出多个Worker进程；</li><li>Worker进程，竞争新的连接，获胜方通过三次握手，建立Socket连接，并处理请求。</li></ol><p>Nginx高性能、高并发：</p><ol><li>Nginx采用：<strong>多进程</strong>+<strong>异步非阻塞</strong>方式（<strong>IO多路复用</strong>epool）</li><li>请求的完整过程：<ol><li>建立连接</li><li>读取请求：解析请求</li><li>处理请求</li><li>相应请求</li></ol></li><li>请求的完整过程，对应到低层，就是：读写socket事件</li></ol><h2 id="Nginx的事件处理模型"><a href="#Nginx的事件处理模型" class="headerlink" title="Nginx的事件处理模型"></a>Nginx的事件处理模型</h2><p>request：Nginx中的http请求。<br>基本的HTTP Web Server工作模式：</p><ol><li><strong>接受请求</strong>：逐行读取<strong>请求行</strong>和<strong>请求头</strong>，判断有请求体后，读取<strong>请求体</strong></li><li><strong>处理请求</strong></li><li><strong>返回响应</strong>：根据处理结果，生成相应的HTTP请求（<strong>响应行</strong>、<strong>响应头</strong>、<strong>响应体</strong>）</li></ol><p>Nginx也是这个套路，整体流程一致：<br><img src="/images/nginx-request-process-model.png" alt=""></p><h2 id="模块化体系结构"><a href="#模块化体系结构" class="headerlink" title="模块化体系结构"></a>模块化体系结构</h2><p><img src="/images/nginx-architecture.png" alt=""><br>nginx的模块根据其功能基本上可以分为以下几种类型：</p><ul><li><strong>event module</strong>：搭建了独立于操作系统的事件处理的框架，及提供了各具体时间的处理。包括ngx_events_module,ngx_event_core_module和ngx_epool_module等。nginx具体使用何种时间处理模块，这依赖于具体的操作系统和编译选项。</li><li><strong>phase handler</strong>：此类型的模块也被直接成为handler模块。主要负责处理客户端请求并产生待相应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</li><li><strong>output filter</strong>：也被成为filter模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有html页面增加预定义的footbar一类的工作，或者对输出的图片的URL进行替换之类的工作。</li><li><strong>upstream</strong>：upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取相应，发回客户端。upstream模块是一种特殊的handler，只不过相应内容不是真正由自己产生的，而是从后端服务器上读取的。</li><li><strong>load-balancer</strong>：负载均衡，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ningg.top/nginx-series-principle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ningg.top/nginx-series-principl
      
    
    </summary>
    
    
    
      <category term="Nginx" scheme="https://chpiter.net/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx限速模块探讨</title>
    <link href="https://chpiter.net/2020/03/09/Nginx%E9%99%90%E9%80%9F%E6%A8%A1%E5%9D%97%E6%8E%A2%E8%AE%A8/"/>
    <id>https://chpiter.net/2020/03/09/Nginx%E9%99%90%E9%80%9F%E6%A8%A1%E5%9D%97%E6%8E%A2%E8%AE%A8/</id>
    <published>2020-03-09T09:59:04.000Z</published>
    <updated>2020-03-10T03:19:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx限速模块探讨，引用：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32391675" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32391675</a></li><li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="noopener">http://tengine.taobao.org/book/index.html</a></li></ul><h1 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h1><p>在探讨Nginx限速模块之前，我们先来看看网络传输中常用两个的流量控制算法：漏桶算法和令牌桶算法。</p><h2 id="漏桶算法（leaky-bucket）"><a href="#漏桶算法（leaky-bucket）" class="headerlink" title="漏桶算法（leaky bucket）"></a>漏桶算法（leaky bucket）</h2><p>漏桶算法（leaky bucket）思想如图所示：<br><img src="/images/v2-2ff7a9dbc1242a4c1abf960efe116813_r.jpg" alt=""><br>一个形象的解释是：</p><ul><li>水（请求）从上方倒入水桶，从水桶下方流出（被处理）；</li><li>来不及流出的水存在水桶中（缓冲），同时水桶中的水以<strong>固定速率</strong>流出；</li><li>水桶满后，水溢出（丢弃）。<br>这个算法的核心是：缓存请求、匀速处理、多余的请求直接丢弃。</li></ul><h2 id="令牌桶算法（token-bucket）"><a href="#令牌桶算法（token-bucket）" class="headerlink" title="令牌桶算法（token bucket）"></a>令牌桶算法（token bucket）</h2><p>令牌桶算法（token bucket）思想如图所示：<br><img src="/images/v2-fe9b3489d9c7a462b5594faf2a80266b_r.jpg" alt=""><br>算法思想是：</p><ul><li>令牌以固定的速率产生，并缓存到令牌桶中；</li><li>令牌桶放满时，多余的令牌被丢弃；</li><li>请求要消耗等比例的令牌才能被处理（处理多少请求，消耗多少令牌）；</li><li>令牌不够时，请求被缓存。</li></ul><p>相比漏桶算法，令牌桶算法不同之处在于它不但有一只“桶”，还有个队列，这个桶是用来存放令牌的，队列才是用来存放请求的。</p><p>从作用上来说，漏桶算法和令牌桶算法最明显的区别就是是否允许<strong>突发流量（burst</strong>的处理，漏桶算法能够<strong>强行限制数据的实时传输（处理）速率</strong>，对突发流量不做额外处理；而令牌桶算法能够在<strong>限制数据的平均传输速率的同时允许某种程度的突发传输</strong>。</p><p>Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阀值。</p><h1 id="Nginx限速模块"><a href="#Nginx限速模块" class="headerlink" title="Nginx限速模块"></a>Nginx限速模块</h1><p>Nginx主要有两种限速方式：按连接数限速（ngx_http_limit_conn_module）、按请求速率限速（ngx_http_limit_req_module）。我们着重讲解按请求速率限速。</p><h2 id="按连接数限速"><a href="#按连接数限速" class="headerlink" title="按连接数限速"></a>按连接数限速</h2><p>按连接数限速是指限制单个IP（或者其他的key）同时发起的连接数，超出这个限制后，Nginx将直接拒绝更多的连接。这个模块的配置比较好理解，详见<a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html" target="_blank" rel="noopener">ngx_http_limit_conn_module官方文档”</a>。</p><h2 id="按请求速率限速"><a href="#按请求速率限速" class="headerlink" title="按请求速率限速"></a>按请求速率限速</h2><p>按请求速率限速是指限制单个IP（或者其他的Key）发送请求的速率，超出指定速率后，Nginx将直接拒绝更多的请求。采用<strong>leaky bucket</strong>算法实现。为深入理解这个模块，我们先从实验现象说起。开始之前我们先简单介绍一个该模块的配置方式，以下面的配置为例：<br><img src="/images/v2-4711d21160627b6aec17baefc8aa3374_720w.jpg" alt=""><br>使用 limit_req_zone 关键字，我们定义一个名为mylimit大小为10MB的共享内存区域（zone），用来存放限速相关的统计信息，限速的 Key 值为二进制的IP地址（$binary_remote_addr），限速上限（rate）为 2r/s；接着我们使用 limit_req 关键字将上述规则作用到 /search/ 上。 burst 和 nodelay 的作用稍后解释。</p><p>使用上述规则，对于 /search/ 目录的访问，单个IP的访问速度被限制在2请求/秒，超过这个限制的访问将直接被Nginx拒绝。</p><h3 id="实验1—毫秒级统计"><a href="#实验1—毫秒级统计" class="headerlink" title="实验1—毫秒级统计"></a>实验1—毫秒级统计</h3><p>我们有如下配置：<br><img src="/images/v2-3dd07cea19be343996f01cfbe276feac_720w.jpg" alt=""><br>上述规则限制了每个IP访问的速度为2r/s，并将该规则作用于跟目录。如果单个IP在非常短的时间内并发发送多个请求，结果会怎样呢？<br><img src="/images/v2-fa8d8095439c4391ef426190c0449c89_720w.jpg" alt=""><br>我们使用单个IP在10ms内并发，并发送了6个请求，只有1个成功，剩下的5个都被拒绝。我们设置的速度是2r/s，为什么只有1个成功呢？<strong>是因为Nginx的限速统计是基于毫秒的，我们限制的速度是2r/s，转换一下就是500ms内单个IP只允许通过1个请求</strong>，从501ms开始才允许通过第二个请求。<br><img src="/images/v2-a923be79e5bfb07aa0e0540c718a967a_720w.jpg" alt=""></p><h3 id="实验2—burst允许缓存处理突发请求"><a href="#实验2—burst允许缓存处理突发请求" class="headerlink" title="实验2—burst允许缓存处理突发请求"></a>实验2—burst允许缓存处理突发请求</h3><p>实验1中我们看到，短时间内发送了大量的请求，Nginx按照毫秒级精度统计，超出限制的请求直接拒绝。这在实际场景中未免过于苛刻，真实网络环境中请求到来不是匀速的，很可能有请求“突发”的情况。Nginx考虑到了这种情况，可以通过<strong>burst</strong>关键字开启对突发请求的缓存处理，而不是直接拒绝。<br>来看我们的配置：<br><img src="/images/v2-2121faf3d728d14e88f9fdb71e84d114_720w.jpg" alt=""><br>我们加入了<strong>burst=4</strong>，意思是每个key（此处是每个IP）最多允许4个突发请求的到来。如果单个IP在10ms内发送6个请求，结果会怎样呢？<br><img src="/images/v2-70b29aa0d30abec245bdea38088d7ded_720w.jpg" alt=""><br>相比实验1成功数增加了4个，与我们设置的burst的数目一直。具体处理流程是：1个请求被立即处理，4个请求被放到burst队列中，另外1个请求被拒绝。<strong>通过设置burst参数，我们是的Nginx限流具备了缓存处理突发流量的能力</strong>。</p><p>但是请注意，burst的作用是让多余的请求可以先放到队列里，慢慢处理。如果不加nodelay参数，队列里的请求<strong>不会立即处理</strong>，而是按照rate设置的速度，以毫秒级精确的速度慢慢处理。</p><h3 id="实验3—nodelay降级排队时间"><a href="#实验3—nodelay降级排队时间" class="headerlink" title="实验3—nodelay降级排队时间"></a>实验3—nodelay降级排队时间</h3><p>实验2中我们看到，通过设置burst参数，我们允许Nginx缓存处理一定程度的突发，多余的请求可以先放到队列里，慢慢处理，起到了平滑流量的作用。但是如果队列设置的比较大，请求排队的时间比较长，用户角度看来就是RT（<strong>响应时间 Response Time</strong>）变长了，这对用户很不友好。有什么解决办法呢？<br><strong>nodelay参数允许请求在排队的时候就立即被处理，也就是说只要请求能够进度burst队列，就会立即被后台worker处理</strong>，请注意，这意味着burst设置了nodelay是，系统瞬间的QPS可能会超过rate设置的阀值。<strong>nodelay</strong>参数要跟<strong>burst</strong>一起使用才有作用。</p><p>延续实验2的配置，我们加入nodelay选项：<br><img src="/images/v2-ceb16668eb99de86d5c812c9cfdbf612_720w.jpg" alt=""><br>单个IP在10ms内并发发送6个请求，结果如下：<br><img src="/images/v2-f73b1d56d201662def37be57528c60ff_720w.jpg" alt=""><br>跟实验2相比，请求成功率没变化，但是<strong>总体耗时变短了</strong>。这怎么解释呢？实验2中，有4个请求被放到burst队列当中，工作进程每隔500ms（rate=2r/s）取一个请求进行处理，最后一个请求要排队2s才会被处理；实验3中，请求放入队列和实验2是一样的，但不同的是，队列中的请求同时具有了被处理的资格，所以实验3中的5个请求可以说是同时开始被处理，花费时间自然变短了。</p><p>但是请注意，虽然设置burst和nodelay能够降低突发请求的处理时间，但是长期来看并不会提高吞吐量的上限，长期吞吐量的上限是由rate决定的，因为nodelay只能保证burst的请求被立即处理，但是Nginx会限制队列元素释放的速度，就像是限制了令牌桶中令牌产生的速度。</p><p>看到这里你可能会问，加入了nodelay参数之后的限速算法，到底算是哪一个“桶”，是漏桶算法还是令牌桶算法？当然还算是漏桶算法。考虑一种情况，令牌桶算法的token未耗尽时会怎么做呢？由于它有一个请求队列，所以会把接下来的请求缓存下来，缓存多少受限于队列大小。但此时缓存这些请求还有意义吗？如果server已经过载，缓存队列越来越长，RT越来越高，即使过了很久请求被处理，对用户来说也没有什么价值了。所以当token不够用时，最明智的做法就是直接拒绝用户的请求，这就成了漏桶算法！</p><h1 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h1><p>具体内容省略，有兴趣的同学可以参看原文或参看源码</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要讲解了Nginx按请求速率限速模块的用法和原理，其中burst和nodelay参数是容易引起误解的，虽然可通过burst允许缓存处理突发请求，结合nodelay能够降低突发请求的处理时间，但是长期来看他们并不会提高吞吐量的上限，长期吞吐量的上限是由rate决定的。需要特别注意的事，burst设置了nodelay时，系统时间的QPS可能会超过rate设置的阀值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx限速模块探讨，引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32391675&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/
      
    
    </summary>
    
    
    
      <category term="Nginx" scheme="https://chpiter.net/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>ITIL思想</title>
    <link href="https://chpiter.net/2020/03/07/ITIL%E6%80%9D%E6%83%B3/"/>
    <id>https://chpiter.net/2020/03/07/ITIL%E6%80%9D%E6%83%B3/</id>
    <published>2020-03-07T10:24:51.000Z</published>
    <updated>2020-03-10T03:19:00.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="ITIL" scheme="https://chpiter.net/tags/ITIL/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习笔记</title>
    <link href="https://chpiter.net/2020/02/22/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://chpiter.net/2020/02/22/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-22T12:25:39.000Z</published>
    <updated>2020-03-10T03:19:29.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
      <category term="MongoDB" scheme="https://chpiter.net/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>纪念我的父亲</title>
    <link href="https://chpiter.net/2020/02/22/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E7%88%B6%E4%BA%B2/"/>
    <id>https://chpiter.net/2020/02/22/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E7%88%B6%E4%BA%B2/</id>
    <published>2020-02-22T12:22:02.000Z</published>
    <updated>2020-02-22T12:22:02.974Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SRE方法论</title>
    <link href="https://chpiter.net/2020/02/21/SRE%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>https://chpiter.net/2020/02/21/SRE%E6%96%B9%E6%B3%95%E8%AE%BA/</id>
    <published>2020-02-21T10:34:30.000Z</published>
    <updated>2020-03-10T09:13:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h1><h2 id="1-确保长期关注运维研发工作"><a href="#1-确保长期关注运维研发工作" class="headerlink" title="1. 确保长期关注运维研发工作"></a>1. 确保长期关注运维研发工作</h2><ul><li>最多 50% 的运维值班内容，最少 50% 的运维开发内容</li><li>控制处理紧急事件的数量，运维人员有充分时间处理故障、恢复服务以及事后进行复盘报告</li><li>事前报警，但是事后总结更加重要：复盘故障发生、报警和处理的全过程，挖掘故障发生的根本原因，提供相应的预防或解决方案，对事不对人</li></ul><h2 id="2-产品稳定性和迭代速度之间的矛盾"><a href="#2-产品稳定性和迭代速度之间的矛盾" class="headerlink" title="2. 产品稳定性和迭代速度之间的矛盾"></a>2. 产品稳定性和迭代速度之间的矛盾</h2><ul><li>可靠性目标 SLO</li><li>错误预算</li><li>利用错误预算，加快产品迭代速度，同时保证服务质量</li><li>最终目标不是“零事故”，而是在稳定和迭代之间寻求平衡，开发和运维之间协作创新</li></ul><h2 id="3-监控系统"><a href="#3-监控系统" class="headerlink" title="3. 监控系统"></a>3. 监控系统</h2><ul><li>紧急报警（alert） ：业务正常运行受到影响，需要紧急处理</li><li>工单（ticket）：业务不受影响，可以延期处理</li><li>日志（logging）：记录应用运行日志，用于调试和事后分析</li></ul><h2 id="4-应急事件处理"><a href="#4-应急事件处理" class="headerlink" title="4. 应急事件处理"></a>4. 应急事件处理</h2><ul><li>MTTF（平均失败时间）</li><li>MTTR（平均恢复时间）</li><li>自动恢复系统，而非需要人工干预，可减少恢复时间</li><li>运维手册（playbook）</li></ul><h2 id="5-变更管理"><a href="#5-变更管理" class="headerlink" title="5. 变更管理"></a>5. 变更管理</h2><ul><li>渐进式发布机制（<a href="https://www.cnblogs.com/nulige/articles/10929182.html" target="_blank" rel="noopener">几种常见的发布方式</a>：<ul><li>蓝绿发布（AB发布）<br>将应用所在集群上的机器从逻辑上分为A/B两组。在新版发布时，首先把A组的机器从负载均衡中摘除，再进行新版本的部署。此时，B组仍然继续提供服务。<br><img src="/images/1053682-20190527095123236-652009308.png" alt=""><br>当A组升级完毕后，负载均衡重新接入A组，再把B组从负载列表中摘除，进行新版本的部署。A组重新提供服务。<br><img src="/images/1053682-20190527095313544-971610690.png" alt=""><br>特点：<ul><li>如果出问题，影响面较广，或者说很难控制具体的影响面</li><li>发布策略简单</li><li>用户无感知，平滑过渡</li><li>升级/回滚速度快<br>缺点：</li><li>需要准备正常业务使用资源的两倍以上服务器，防止升级期间单组无法承载业务突发</li><li>短时间内浪费一定资源成本</li><li>基础设施无改动，增大升级稳定性<br>蓝绿发布在早期物理服务器时代，还是比较昂贵的，由于云计算普及，成本也大大降低</li></ul></li><li>灰度发布<br>灰度发布只升级部分服务，即让一部分用户继续用老版本，一部分用户开始用新版本，如果用户对新版本没什么意见，那么逐步扩大范围，把所有用户都迁移到新版本上面来。<br><img src="/images/1053682-20190527095414439-329213436.png" alt=""><br>特点：<ul><li>保证整体系统稳定性，在初始灰度的时候就可以发现、调整问题，影响范围可控</li><li>新功能逐步评估性能，稳定性和健康状况，如果出问题影响范围很小，相对用户体验也少</li><li>用户无感知，平滑过渡<br>缺点：</li><li>自动化要求高<br>部署过程：</li><li>从LB摘掉灰度服务器，升级成功后再加入LB</li><li>少量用户流量到新版本</li><li>如果灰度服务器测试成功，升级剩余服务器<br>灰度发布是通过切换线上并存版本之间的路由权重，逐步从一个版本切换为另一个版本的过程</li></ul></li><li>滚动发布<br>滚动发布是指每次只升级一个或多个服务，升级完成后加入生产环境，不断执行这个过程，直到集群中的全部旧版本升级新版本。<br><img src="/images/1053682-20190527095443475-675603692.png" alt=""><ul><li>红色：正在更新的实例</li><li>蓝色：更新完成并加入集群的实例</li><li>绿色：正在运行的实例<br>特点：</li><li>用户无感知，平滑过渡</li><li>节约资源<br>缺点：</li><li>部署时间慢，取决于每阶段更新时间</li><li>发布策略较复杂</li><li>无法确定OK的环境，不易回滚<br>部署过程：</li><li>先升级1个副本，主要做部署验证</li><li>每次升级副本，自动从LB上摘掉，升级成功后自动加入集群</li><li>事先需要有自动更新策略，分为若干次，每次数量/百分比可配置</li><li>回滚是发布的逆过程，先从LB摘掉新版本，再升级老版本，这个过程一般时间比较长</li><li>自动化要求高</li></ul></li><li>小结<br>综上所述，三种方式均可以做到平滑式升级，在升级过程中服务仍然保持服务的连续性，升级对外界是无感知的。那生产上选择哪种部署方法最合适呢？这取决于哪种方法最适合你的业务和技术需求。如果你们运维自动化能力储备不够，肯定是越简单越好，建议蓝绿发布，如果业务对用户依赖很强，建议灰度发布。如果是K8S平台，滚动更新是现成的方案，建议先直接使用<ul><li>蓝绿发布：两套环境交替升级，旧版本保留一定时间便于回滚</li><li>灰度发布：根据比例将老版本升级，例如80%用户访问是老版本，20%用户访问是新版本</li><li>滚动发布：按批次停止老版本实例，启动新版本实例</li></ul></li></ul></li><li>迅速而准确的检测到问题的发生</li><li>当出现问题时，安全迅速的回退改动</li></ul><h2 id="6-需求预测和容量规划"><a href="#6-需求预测和容量规划" class="headerlink" title="6. 需求预测和容量规划"></a>6. 需求预测和容量规划</h2><p>业务的容量规划，包括自然增长（随着用户使用量上升，资源使用量也上升），也包括一些非自然增长的因素（如新功能的发布，商业推广，以及其他商业因素在内）</p><ul><li>必须有一个准确的自然增长需求预测模型，需求预测的时间应该超过资源获取的时间</li><li>规划中必须有准确的非自然增长的需求来源的统计</li><li>必须有周期性的压力测试，以便准确的将系统原始资源信息与业务容量对应起来</li></ul><h2 id="7-资源部署"><a href="#7-资源部署" class="headerlink" title="7. 资源部署"></a>7. 资源部署</h2><p>资源部署是变更管理与容量规划的结合产物。</p><ul><li>资源部署和配置必须迅速完成</li><li>仅在必要的时候执行，因为资源有限且昂贵</li><li>保证部署和配置过程执行的正确性，否则资源不可用</li><li>部署和配置过程影响较大，会有较大幅度修改，必须执行一系列测试，确保可以正确的提供服务</li></ul><h2 id="8-效率与性能"><a href="#8-效率与性能" class="headerlink" title="8. 效率与性能"></a>8. 效率与性能</h2><ul><li>高效的利用资源，盈利的必要性</li><li>SRE负责容量的部署和配置，承担有关利用率的讨论和改进</li><li>服务的利用率指标依赖于服务的工作方式和对容量的配置与部署</li><li>关注服务的容量配置策略，提升资源利用率，可以有效的降低系统成本<br>业务总体资源的使用情况的关键驱动因素：<ul><li>用户需求</li><li>可用容量</li><li>软件的资源使用效率<br>SRE可以通过模型预测用户需求，合理部署和配置可用容量，同时可以改进软件以提升资源的使用效率。通过这三个因素可以大幅度提升服务的效率。<br>软件系统一般来说在负载上升的时候，会导致延迟升高。延迟升高其实和容量损失是一样的。当负载达到临界线的时候，一个逐渐变慢的系统最终会停止一切服务。SRE的目标是根据一个预设的延迟目标，部署和维护足够的容量。SRE和研发团队应该共同监控和优化整个系统的性能，这就相当于给服务增加容量和提升效率了。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法论&quot;&gt;&lt;a href=&quot;#方法论&quot; class=&quot;headerlink&quot; title=&quot;方法论&quot;&gt;&lt;/a&gt;方法论&lt;/h1&gt;&lt;h2 id=&quot;1-确保长期关注运维研发工作&quot;&gt;&lt;a href=&quot;#1-确保长期关注运维研发工作&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
      <category term="SRE" scheme="https://chpiter.net/tags/SRE/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown常用语法</title>
    <link href="https://chpiter.net/2020/02/20/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>https://chpiter.net/2020/02/20/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2020-02-20T06:38:04.000Z</published>
    <updated>2020-03-11T01:08:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、标题<br><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code><br><strong>【最多六级】</strong></p><p>二、字体<br><strong>加粗文字</strong><br><em>倾斜文字</em><br><strong><em>加粗倾斜文字</em></strong><br><del>删除线文字</del></p><p>三、引用</p><blockquote><p>引用</p><blockquote><p>引用</p><blockquote><p>引用</p></blockquote></blockquote></blockquote><p>四、分割线</p><hr><hr><hr><hr><p>五、图片</p><p>![图片alt](图片地址 ‘’图片title’’)</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&fm=27&gp=0.jpg" alt="blockchain" title="区块链"></p><p>六、超链接<br><a href="超链接地址" title="超链接title">超链接名</a><br>title可加可不加</p><p>七、列表<br>无序列表</p><ul><li>a</li></ul><ul><li>b</li></ul><ul><li>c</li></ul><p>有序列表</p><ol><li>a</li><li>b</li><li>c</li></ol><p>注意序号和内容之间的空格</p><p>列表嵌套：上下级列表使用3个空格</p><ul><li>a<ul><li>b<ul><li>c</li></ul></li></ul></li></ul><p>十、流程图</p><p>`` <div id="flowchart-0" class="flow-chart"></div></p><div id="flowchart-1" class="flow-chart"></div><p>十一、表格</p><p><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">`` st=>start: 开始`` op=>operation: My Operation`` cond=>condition: Yes or No?`` e=>end`` st->op->cond`` cond(yes)->e`` cond(no)->op`` &</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: 开始op=>operation: My Operationcond=>condition: Yes or No?e=>endst->op->condcond(yes)->econd(no)->op&</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、标题&lt;br&gt;&lt;code&gt;# 一级标题&lt;/code&gt;&lt;br&gt;&lt;code&gt;## 二级标题&lt;/code&gt;&lt;br&gt;&lt;code&gt;### 三级标题&lt;/code&gt;&lt;br&gt;&lt;code&gt;### 四级标题&lt;/code&gt;&lt;br&gt;&lt;code&gt;##### 五级标题&lt;/code&gt;&lt;br&gt;&lt;code
      
    
    </summary>
    
    
    
      <category term="markdown" scheme="https://chpiter.net/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>运维思考</title>
    <link href="https://chpiter.net/2020/02/20/opsthink/"/>
    <id>https://chpiter.net/2020/02/20/opsthink/</id>
    <published>2020-02-20T05:47:08.000Z</published>
    <updated>2020-03-10T03:19:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运维管理思考"><a href="#运维管理思考" class="headerlink" title="运维管理思考"></a>运维管理思考</h1><h2 id="技术管理"><a href="#技术管理" class="headerlink" title="技术管理"></a>技术管理</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运维管理思考&quot;&gt;&lt;a href=&quot;#运维管理思考&quot; class=&quot;headerlink&quot; title=&quot;运维管理思考&quot;&gt;&lt;/a&gt;运维管理思考&lt;/h1&gt;&lt;h2 id=&quot;技术管理&quot;&gt;&lt;a href=&quot;#技术管理&quot; class=&quot;headerlink&quot; title=&quot;技
      
    
    </summary>
    
    
    
      <category term="ops" scheme="https://chpiter.net/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>AboutMe</title>
    <link href="https://chpiter.net/2020/02/17/AboutMe/"/>
    <id>https://chpiter.net/2020/02/17/AboutMe/</id>
    <published>2020-02-17T13:06:08.000Z</published>
    <updated>2020-02-17T13:11:54.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
